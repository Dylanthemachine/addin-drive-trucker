{"version":3,"sources":["scripts/main.js"],"names":["geotab","addin","driveTrucker","PointsCache","elAddin","elRoot","observer","api","directionsService","mapMoveWait","updateParkingWait","watchId","unitSystem","controller","AbortController","nightMode","elementType","stylers","color","featureType","latLng","lat","lng","errorHandler","err","console","error","code","loading","updateParking","location","radius","abort","fetch","DemoEndpoint","signal","then","response","json","parking","forEach","Lat","Lon","center","parkingLocations","Object","values","catch","toggleNightMode","isNightMode","$refs","mapRef","$mapPromise","map","setOptions","styles","initialize","freshApi","freshState","initializeCallback","document","getElementById","Vue","use","VueGoogleMaps","load","key","libraries","component","Cluster","el","data","marker","zoom","mapOptions","mapType","disableDefaultUI","gestureHandling","selected","directions","polylineOuterOptions","strokeColor","strokeOpacity","strokeWeight","polylineInnerOptions","infoContent","distance","duration","infoWindowPos","infoWinOpen","currentMidx","infoOptions","pixelOffset","width","height","methods","navigate","e","preventDefault","sLat","sLng","dLat","dLng","url","mobile","exists","test","navigator","userAgent","window","MSStream","open","zoomChange","level","centerChanged","coords","clearTimeout","setTimeout","zoomMapTo","event","toggleSatelite","setMapTypeId","boundsChanged","bounds","getBounds","getCenter","ne","getNorthEast","lat1","lon1","lat2","lon2","dis","Math","acos","sin","cos","toggleInfoWindow","parkingLocation","idx","origin","destination","Promise","resolve","rejsect","route","travelMode","status","reject","routes","overview_path","leg","legs","name","types","gas_station","convenience_store","store","restaurant","google","maps","places","PlacesService","nearbySearch","typeNames","keys","PlacesServiceStatus","OK","filteredPlaces","filter","p","some","t","includes","sort","p1","p2","sortNumber","a","b","typeToValue","vals1","vals2","length","placeName","end_address","loaded","DirectionsService","getSession","session","call","typeName","search","userName","results","isMetric","UnitSystem","METRIC","IMPERIAL","MutationObserver","mutations","mutation","attributeName","target","classList","contains","focus","device","addinContent","querySelector","style","observe","attributes","querySelectorAll","geolocation","watchPosition","position","latitude","longitude","assign","enableHighAccuracy","timeout","maximumAge","blur","clearWatch","disconnect"],"mappings":"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","file":"main.js","sourcesContent":["'use strict';\n\n/**\r\n * @returns {{initialize: Function, focus: Function, blur: Function}}\r\n */\ngeotab.addin.driveTrucker = function () {\n    'use strict';\n\n    var GoogleMapsKey = '';\n    var PointsCache = {};\n\n    // the root container\n    var elAddin = void 0;\n    var elRoot = void 0;\n    var observer = void 0;\n    var api = void 0;\n    var device = void 0;\n    var directionsService = void 0;\n    var mapMoveWait = void 0;\n    var updateParkingWait = void 0;\n    var watchId = void 0;\n    var unitSystem = void 0;\n    var controller = new AbortController();\n    var nightMode = [{ elementType: 'geometry', stylers: [{ color: '#242f3e' }] }, { elementType: 'labels.text.stroke', stylers: [{ color: '#242f3e' }] }, { elementType: 'labels.text.fill', stylers: [{ color: '#746855' }] }, {\n        featureType: 'administrative.locality',\n        elementType: 'labels.text.fill',\n        stylers: [{ color: '#d59563' }]\n    }, {\n        featureType: 'poi',\n        elementType: 'labels.text.fill',\n        stylers: [{ color: '#d59563' }]\n    }, {\n        featureType: 'poi.park',\n        elementType: 'geometry',\n        stylers: [{ color: '#263c3f' }]\n    }, {\n        featureType: 'poi.park',\n        elementType: 'labels.text.fill',\n        stylers: [{ color: '#6b9a76' }]\n    }, {\n        featureType: 'road',\n        elementType: 'geometry',\n        stylers: [{ color: '#38414e' }]\n    }, {\n        featureType: 'road',\n        elementType: 'geometry.stroke',\n        stylers: [{ color: '#212a37' }]\n    }, {\n        featureType: 'road',\n        elementType: 'labels.text.fill',\n        stylers: [{ color: '#9ca5b3' }]\n    }, {\n        featureType: 'road.highway',\n        elementType: 'geometry',\n        stylers: [{ color: '#746855' }]\n    }, {\n        featureType: 'road.highway',\n        elementType: 'geometry.stroke',\n        stylers: [{ color: '#1f2835' }]\n    }, {\n        featureType: 'road.highway',\n        elementType: 'labels.text.fill',\n        stylers: [{ color: '#f3d19c' }]\n    }, {\n        featureType: 'transit',\n        elementType: 'geometry',\n        stylers: [{ color: '#2f3948' }]\n    }, {\n        featureType: 'transit.station',\n        elementType: 'labels.text.fill',\n        stylers: [{ color: '#d59563' }]\n    }, {\n        featureType: 'water',\n        elementType: 'geometry',\n        stylers: [{ color: '#17263c' }]\n    }, {\n        featureType: 'water',\n        elementType: 'labels.text.fill',\n        stylers: [{ color: '#515c6d' }]\n    }, {\n        featureType: 'water',\n        elementType: 'labels.text.stroke',\n        stylers: [{ color: '#17263c' }]\n    }];\n\n    /**\r\n     * Converts lat,lng values to object\r\n     * @param  {Number} lat The latitude\r\n     * @param  {Number} lng The longitude\r\n     * @returns {Object} The lat,lng object\r\n     */\n    var latLng = function latLng(lat, lng) {\n        return { lat: lat, lng: lng };\n    };\n\n    /**\r\n     * Crude error handler will log to console\r\n     * @param  {any} err The error object or string message\r\n     */\n    var errorHandler = function errorHandler(err) {\n        console.error(err);\n\n        // don't stop loading spinner when we cancel the fetch\n        if (err.code === 20) {\n            return;\n        }\n\n        elAddin.loading = false;\n        return;\n    };\n\n    // The cloud function endpoint\n    var DemoEndpoint = 'https://us-central1-geotab-demo-project.cloudfunctions.net';\n\n    /**\r\n     * Gets truck parking locations for the given location and radius\r\n     * @param  {Object} location The lat,lng coordiantes center point\r\n     * @param  {Number} radius The radius in meters\r\n     * @returns {Promise} A list of parking locations\r\n     */\n    var updateParking = function updateParking(location, radius) {\n        // abort any fetch which is already open and make new fetch\n        controller.abort();\n        controller = new AbortController();\n\n        elAddin.loading = true;\n        return fetch(DemoEndpoint + '/truckParkingLocation?latitude=' + location.lat + '&longitude=' + location.lng + '&radius=' + radius + '&limit=1000', { signal: controller.signal }).then(function (response) {\n            return response.json();\n        }).then(function (parking) {\n            parking.forEach(function (location) {\n                // cache points we already looked up\n                PointsCache[location.Lat + 'x' + location.Lon] = {\n                    center: latLng(location.Lat, location.Lon)\n                };\n            });\n\n            // update markers in our vuew\n            elAddin.parkingLocations = Object.values(PointsCache);\n            elAddin.loading = false;\n        }).catch(errorHandler);\n    };\n\n    /**\r\n     * Get the route from an origin to a destination from map provider\r\n     * @param  {Object} origin The lat,lng origin\r\n     * @param  {Object} destination The lat,lng destination\r\n     * @param  {String} unitSystem The users's prefered unit system\r\n     * @returns {Promise} The route response from map provider\r\n     */\n    var getRoute = function getRoute(origin, destination, unitSystem) {\n        return new Promise(function (resolve, rejsect) {\n            directionsService.route({\n                origin: origin,\n                destination: destination,\n                travelMode: 'DRIVING',\n                unitSystem: unitSystem\n            }, function (response, status) {\n                if (status === 'OK') {\n                    resolve(response);\n                } else {\n                    reject('Directions request failed due to ' + status);\n                }\n            });\n        });\n    };\n\n    /**\r\n     * Estimates a place name for a location, giving priority to places we think trucks might park (fuel stations, truck stops, etc)\r\n     * @param  {Object} location The lat,lng location to find the place name of\r\n     * @returns {Promise} The place name\r\n     */\n    var estimatePlace = function estimatePlace(location) {\n        return new Promise(function (resolve, rejsect) {\n            elAddin.$refs.mapRef.$mapPromise.then(function (map) {\n                // higher likleyhood this is where truck parking is\n                var types = {\n                    'gas_station': 1,\n                    'convenience_store': 2,\n                    'store': 3,\n                    'restaurant': 4\n                };\n\n                // call Google places API\n                var service = new google.maps.places.PlacesService(map);\n\n                service.nearbySearch({\n                    location: location,\n                    radius: 500\n                }, function (places, status) {\n\n                    var typeNames = Object.keys(types);\n\n                    if (status == google.maps.places.PlacesServiceStatus.OK) {\n                        // filter out places not in prefered types\n                        var filteredPlaces = places.filter(function (p) {\n                            return p.types.some(function (t) {\n                                return typeNames.includes(t);\n                            });\n                        });\n\n                        // sort by place type rank\n                        filteredPlaces = filteredPlaces.sort(function (p1, p2) {\n                            var sortNumber = function sortNumber(a, b) {\n                                return a - b;\n                            };\n                            var typeToValue = function typeToValue(p) {\n                                return types[p] || 1000;\n                            };\n                            var vals1 = p1.types.map(typeToValue).sort(sortNumber);\n                            var vals2 = p2.types.map(typeToValue).sort(sortNumber);\n\n                            return vals1[0] - vals2[0];\n                        });\n\n                        // if there's nothing prefered, fallback to first closest place name\n                        resolve(filteredPlaces.length > 0 ? filteredPlaces[0].name : places[0].name);\n                    } else {\n                        reject('Places request failed due to ' + status);\n                    }\n                });\n            });\n        });\n    };\n\n    /**\r\n     * Toggle night mode map style\r\n     * @param  {Boolean} isNightMode [true] if night mode, otherwise [false]\r\n     */\n    var toggleNightMode = function toggleNightMode(isNightMode) {\n        elAddin.$refs.mapRef.$mapPromise.then(function (map) {\n            map.setOptions({ styles: isNightMode ? nightMode : [] });\n        });\n    };\n\n    return {\n        /**\r\n         * initialize() is called only once when the Add-In is first loaded. Use this function to initialize the\r\n         * Add-In's state such as default values or make API requests (MyGeotab or external) to ensure interface\r\n         * is ready for the user.\r\n         * @param {object} freshApi - The GeotabApi object for making calls to MyGeotab.\r\n         * @param {object} freshState - The page state object allows access to URL, page navigation and global group filter.\r\n         * @param {function} initializeCallback - Call this when your initialize route is complete. Since your initialize routine\r\n         *        might be doing asynchronous operations, you must call this method when the Add-In is ready\r\n         *        for display to the user.\r\n         */\n        initialize: function initialize(freshApi, freshState, initializeCallback) {\n            api = freshApi;\n\n            elRoot = document.getElementById('app');\n\n            // setup vue to use Google maps component\n            Vue.use(VueGoogleMaps, {\n                load: {\n                    key: GoogleMapsKey,\n                    libraries: 'places'\n                }\n            });\n\n            // gmapCluster *must* be manually imported\n            Vue.component('gmap-cluster', VueGoogleMaps.Cluster);\n\n            // the add-in vue\n            elAddin = new Vue({\n                el: '#driveTrucker',\n                data: function data() {\n                    return {\n                        // map center\n                        center: latLng(0, 0),\n                        // device center\n                        marker: latLng(0, 0),\n                        // map\n                        zoom: 10,\n                        mapOptions: {\n                            styles: [],\n                            mapType: 'roadmap',\n                            disableDefaultUI: true,\n                            gestureHandling: 'greedy'\n                        },\n                        // search raduis\n                        radius: 200,\n                        parkingLocations: [],\n                        selected: {},\n                        // directions polyline options\n                        directions: [],\n                        polylineOuterOptions: {\n                            strokeColor: '#FFFFFF',\n                            strokeOpacity: 1.0,\n                            strokeWeight: 6\n                        },\n                        polylineInnerOptions: {\n                            strokeColor: '#1976d2',\n                            strokeOpacity: 1.0,\n                            strokeWeight: 4\n                        },\n                        // info window\n                        infoContent: {\n                            distance: {},\n                            duration: {}\n                        },\n                        infoWindowPos: null,\n                        infoWinOpen: false,\n                        currentMidx: null,\n                        infoOptions: {\n                            pixelOffset: {\n                                width: 0,\n                                height: -35\n                            }\n                        }\n                    };\n                },\n\n                methods: {\n                    /**\r\n                     * Navigate to the selected truck parking location. Calls out to device navigation.\r\n                     * @param  {Event} e The event\r\n                     */\n                    navigate: function navigate(e) {\n                        e.preventDefault();\n\n                        var sLat = elAddin.marker.lat;\n                        var sLng = elAddin.marker.lng;\n                        var dLat = elAddin.selected.center.lat;\n                        var dLng = elAddin.selected.center.lng;\n\n                        var url = '';\n\n                        if (api.mobile.exists()) {\n                            // IOS\n                            var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n                            if (isIOS) {\n                                url = 'maps://?q=' + dLat + ',' + dLng;\n                            } else {\n                                // Android\n                                url = 'geo:' + sLat + ',' + sLng + '?q=' + dLat + ',' + dLng;\n                            }\n                        } else {\n                            // Browser\n                            url = 'https://maps.google.com/maps?saddr=' + sLat + ',' + sLng + '&daddr=' + dLat + ',' + dLng;\n                        }\n\n                        window.open(url, '_system');\n                    },\n\n                    /**\r\n                     * Zoom the map to a given level\r\n                     * @param  {Number} level The zoom level\r\n                     */\n                    zoomChange: function zoomChange(level) {\n                        elAddin.zoom = level;\n                    },\n\n                    /**\r\n                     * Update center on center changed event\r\n                     * @param  {Object} coords The lat,lng coordiates of map center\r\n                     */\n                    centerChanged: function centerChanged(coords) {\n                        clearTimeout(mapMoveWait);\n                        mapMoveWait = setTimeout(function () {\n                            elAddin.center = latLng(coords.lat(), coords.lng());\n                        }, 1000);\n                    },\n\n                    /**\r\n                     * Zoom the map to a given location and zoom level\r\n                     * @param  {Object} center The lat,lng coordiates of map center\r\n                     * @param  {Number} zoom The zoom level\r\n                     * @param  {Event} event The 'click' event\r\n                     */\n                    zoomMapTo: function zoomMapTo(center, zoom, event) {\n                        event.preventDefault();\n                        elAddin.zoom = zoom;\n                        elAddin.center = center;\n                    },\n\n                    /**\r\n                     * Toggle satelite map tiles on/off\r\n                     */\n                    toggleSatelite: function toggleSatelite() {\n                        if (elAddin.mapOptions.mapType === 'roadmap') {\n                            elAddin.mapOptions.mapType = 'satellite';\n                        } else {\n                            elAddin.mapOptions.mapType = 'roadmap';\n                        }\n                        elAddin.$refs.mapRef.$mapPromise.then(function (map) {\n                            map.setMapTypeId(elAddin.mapOptions.mapType);\n                        });\n                    },\n\n                    /**\r\n                     * When map bounds change update parking locations using map center point and bounds to determin radius to search.\r\n                     */\n                    boundsChanged: function boundsChanged() {\n                        elAddin.$refs.mapRef.$mapPromise.then(function (map) {\n                            var bounds = map.getBounds();\n\n                            var center = bounds.getCenter();\n                            var ne = bounds.getNorthEast();\n\n                            // r = radius of the earth in statute miles\n                            var r = 3963.0;\n\n                            // Convert lat or lng from decimal degrees into radians (divide by 57.2958)\n                            var lat1 = center.lat() / 57.2958;\n                            var lon1 = center.lng() / 57.2958;\n                            var lat2 = ne.lat() / 57.2958;\n                            var lon2 = ne.lng() / 57.2958;\n\n                            // distance = circle radius from center to Northeast corner of bounds\n                            var dis = r * Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1));\n\n                            clearTimeout(updateParkingWait);\n                            updateParkingWait = setTimeout(function () {\n                                updateParking(elAddin.center, dis);\n                            }, 500);\n                        });\n                    },\n\n                    /**\r\n                     * Open info window for parking location. Uses parking location to look-up route and likley place names from Google Directions and Places APIs.\r\n                     * @param  {Object} parkingLocation The parking location (marker) details\r\n                     * @param  {Number} idx The current marker id\r\n                     */\n                    toggleInfoWindow: function toggleInfoWindow(parkingLocation, idx) {\n                        elAddin.loading = true;\n\n                        elAddin.selected = parkingLocation;\n\n                        getRoute(elAddin.marker, parkingLocation.center, unitSystem).then(function (response) {\n                            var route = response.routes[0];\n                            elAddin.directions = route.overview_path;\n\n                            var leg = route.legs[0];\n                            leg.name = '...';\n                            elAddin.infoContent = leg;\n                            elAddin.infoWindowPos = parkingLocation.center;\n\n                            // check if its the same marker that was selected if yes toggle\n                            if (elAddin.currentMidx == idx) {\n                                elAddin.infoWinOpen = !elAddin.infoWinOpen;\n                            }\n                            // if different marker set infowindow to open and reset current marker index\n                            else {\n                                    elAddin.infoWinOpen = true;\n                                    elAddin.currentMidx = idx;\n                                }\n                        }).then(function () {\n                            return estimatePlace(parkingLocation.center);\n                        }).then(function (placeName) {\n                            elAddin.infoContent.name = placeName;\n                            elAddin.loading = false;\n                        }).catch(function (err) {\n                            elAddin.infoContent.name = elAddin.infoContent.end_address;\n                            errorHandler(err);\n                        });\n                    }\n                }\n            });\n\n            VueGoogleMaps.loaded.then(function () {\n                // vue Google maps loads maps api into window, create DirectionsService once the library is loaded \n                directionsService = new google.maps.DirectionsService();\n\n                // get current user unit system which will be used to query DirectionsService for distance\n                api.getSession(function (session) {\n                    api.call('Get', {\n                        typeName: 'User',\n                        search: {\n                            name: session.userName\n                        }\n                    }, function (results) {\n                        unitSystem = results[0].isMetric ? google.maps.UnitSystem.METRIC : google.maps.UnitSystem.IMPERIAL;\n                    }, function (err) {\n                        console.error(err);\n                    });\n                });\n            });\n\n            // mutation observer to see if night mode is toggled on the DOM\n            observer = new MutationObserver(function (mutations) {\n                mutations.forEach(function (mutation) {\n                    if (mutation.attributeName === 'class') {\n                        toggleNightMode(mutation.target.classList.contains('nightMode'));\n                    }\n                });\n            });\n\n            // MUST call initializeCallback when done any setup\n            initializeCallback();\n        },\n\n\n        /**\r\n         * focus() is called whenever the Add-In receives focus.\r\n         *\r\n         * The first time the user clicks on the Add-In menu, initialize() will be called and when completed, focus().\r\n         * focus() will be called again when the Add-In is revisited. Note that focus() will also be called whenever\r\n         * the global state of the MyGeotab application changes, for example, if the user changes the global group\r\n         * filter in the UI.\r\n         *\r\n         * @param {object} freshApi - The GeotabApi object for making calls to MyGeotab.\r\n         * @param {object} freshState - The page state object allows access to URL, page navigation and global group filter.\r\n         */\n        focus: function focus(freshApi, freshState) {\n            api = freshApi;\n\n            device = freshState.device;\n\n            // hack to better display map\n            if (api.mobile.exists()) {\n                var addinContent = document.querySelector('#content.addin-content');\n                if (addinContent) {\n                    addinContent.style.height = 'height: calc(100% - 62px) !important';\n                }\n            }\n\n            // watching root for night mode css change\n            observer.observe(elRoot, {\n                attributes: true\n            });\n\n            // if device is in 'nightmode' toggle night mode map tiles\n            toggleNightMode(document.querySelectorAll('#app.nightMode').length > 0);\n\n            // watch device location to update on the map\n            var geolocation = api.mobile && api.mobile.geolocation || navigator.geolocation;\n            watchId = navigator.geolocation.watchPosition(function (position) {\n                var location = latLng(position.coords.latitude, position.coords.longitude);\n                if (!elAddin.center.lat) {\n                    elAddin.center = Object.assign({}, location);\n                    updateParking(location, elAddin.radius);\n                }\n\n                elAddin.marker = Object.assign({}, location);\n            }, errorHandler, {\n                enableHighAccuracy: false,\n                timeout: 5000,\n                maximumAge: 0\n            });\n        },\n\n\n        /**\r\n         * blur() is called whenever the user navigates away from the Add-In.\r\n         *\r\n         * Use this function to save the page state or commit changes to a data store or release memory.\r\n         *\r\n         * @param {object} freshApi - The GeotabApi object for making calls to MyGeotab.\r\n         * @param {object} freshState - The page state object allows access to URL, page navigation and global group filter.\r\n         */\n        blur: function blur() {\n            navigator.geolocation.clearWatch(watchId);\n            observer.disconnect();\n        }\n    };\n};\n//# sourceMappingURL=main.js.map\n"]}